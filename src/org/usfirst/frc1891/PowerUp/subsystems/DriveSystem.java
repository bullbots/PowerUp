// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1891.PowerUp.subsystems;

import java.util.LinkedList;

import org.usfirst.frc1891.PowerUp.RobotMap;
import org.usfirst.frc1891.PowerUp.commands.*;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;



/**
 *
 */
public class DriveSystem extends Subsystem {
	
	public enum Gear {
		LowGear,
		HighGear
	}
	
	public enum DriveTrainControlMode {
		OperatorControl,
		DriveForward,
		TurnInPlace,
		Stopped
	}

    private final WPI_TalonSRX leftMasterTalon = RobotMap.driveSystemLeftMasterTalon;
    private final WPI_TalonSRX leftSlaveTalon = RobotMap.driveSystemLeftSlaveTalon;
    private final WPI_TalonSRX rightMasterTalon = RobotMap.driveSystemRightMasterTalon;
    private final WPI_TalonSRX rightSlaveTalon = RobotMap.driveSystemRightSlaveTalon;
    
    private final DoubleSolenoid shifter;
    
    private final AHRS navx = RobotMap.ahrs;
    
    private final AnalogInput leftRangeFinder = RobotMap.leftRangeFinder;
    private final AnalogInput rightRangeFinder = RobotMap.rightRangeFinder;
    
    private DriveTrainControlMode currentMode = DriveTrainControlMode.Stopped;
    /**
     * Variable to keep track of how the driver wants shifting to be controlled.
     */
    private boolean doAutoShift = false;
//    /**
//     * Set when we want to change gears, gear change decision made based off of this. 
//     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
//     */
//    private boolean wantsLowGear = true;
//    /**
//     * Set when we want to change gears, gear change decision made based off of this. 
//     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
//     */
//    private boolean wantsHighGear = false;
    
    private Gear wantedGear = Gear.LowGear;
    
    private double leftSpeedTarget = 0;
    private double rightSpeedTarget = 0;
    private boolean driverDamp = false;
    /**
     * State Variable for position control of drivetrain for auto driving (using the motion magic mode on
     * TalonSRXs) versus normal operator control.
     */
    private boolean inMotionMagicMode = false;
    
    private boolean motionRunning = false;
	private int motionMagicSetPoint = 0;
	
    private boolean turnRunning = false;
    private double turnSetPoint = 0;
    private double turndisplacement = 0;
    private LinkedList<Double> turnPosition = new LinkedList<Double>();
    private PIDController turnController;
    
    /**
     * State Variable for current physical gearing.
     */
    private Gear currentGear = Gear.LowGear;
    
    
    /*
     * Members used to determine average speed of either side of drive. Used for autoshifting.
     */
    private LinkedList<Integer> leftSideVelocityBuffer = new LinkedList<Integer>();
    private LinkedList<Integer> rightSideVelocityBuffer = new LinkedList<Integer>();
    private int leftSideAverageSpeedEncoder;
    private int rightSideAverageSpeedEncoder;
    
    
    
    // DriveTrain Constant values
    public static final int leftSideLowGearTopSpeed = 12041;
    public static final int rightSideLowGearTopSpeed = 11682;
    public static final int leftSideHighGearTopSpeed = 24770;
    public static final int rightSideHighGearTopSpeed = 24482;
    
    public static final double leftSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideLowGearTopSpeed);
    public static final double rightSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideLowGearTopSpeed);
    public static final double leftSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideHighGearTopSpeed);
    public static final double rightSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideHighGearTopSpeed);

    public static final int enforcedLowGearTopSpeed = 11000;
    public static final int enforcedHighGearTopSpeed = 24000;
    
    public static final double enforcedLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(11000);
    public static final double enforcedHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(24000);
    
	public static final double wheelDiameterFeet = 0.5;
	public static final double encoderRevsPerWheelRev = 7.5;
	
	private static final double allowableError = 2000;
	
	public static final int maxLowGearAcceleration = enforcedLowGearTopSpeed / 2;
	
	private int leftPositionZero = 0;
	private int rightPositionZero = 0;
	
	// fields used for debug
	public int printTimerCount = 0;
    private int topLeft;
    private int topRight;
    private double lastAngle;
	private double targetAngle;
	private boolean rotating;
	private boolean rotateTimeout;
    private PIDController operatorStraightener;
	private double opTurnDisplacement;
	private Timer opTurnTimer = new Timer();
    
    private class TurnSource implements PIDSource {

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			// TODO check feedback, maybe needs to be complicated
			return navx.getYaw();
		}
    	
    }
	
	public DriveSystem() {
		shifter = new DoubleSolenoid(RobotMap.ShifterLowPort, RobotMap.ShifterHighPort);
		setGear(Gear.LowGear);
		
		turnController = new PIDController(300, 0, 0, new TurnSource(), new PIDOutput() {
			public void pidWrite(double output) {
				turndisplacement = output;
			}
		});
		turnController.setInputRange(-180, 180);
		turnController.setOutputRange(-2200, 2200);
		turnController.setAbsoluteTolerance(3);
		turnController.setContinuous();
		
		operatorStraightener = new PIDController(300, 0, 0, new TurnSource(), new PIDOutput() {
			public void pidWrite(double output) {
				opTurnDisplacement = output;
			}
		});
		operatorStraightener.setInputRange(-180, 180);
		operatorStraightener.setOutputRange(-2200, 2200);
		operatorStraightener.setAbsoluteTolerance(3);
		operatorStraightener.setContinuous();
		operatorStraightener.enable();
	}
    
    

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new JoystickDrive());
    }

    @Override
    public void periodic() {
    	// motion magic check
    	if (currentMode == DriveTrainControlMode.DriveForward && motionRunning) {
        	leftMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint + leftPositionZero);
        	rightMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint + rightPositionZero);
    	} 
    	// Turn check
    	else if (currentMode == DriveTrainControlMode.TurnInPlace && turnRunning) {
//    		double error = turnSetPoint - navx.getYaw();
//    		if (error > 180) {
//    			error = error - 360;
//    		}
//    		else if (error < -180) {
//    			error = error + 360;
//    		}
//			turnPosition.addFirst(error);
//    		if (turnPosition.size() > 10) {
//    			turnPosition.removeLast();
//    		}
//    		for (Double d : turnPosition) {
//    			error += d;
//    		}
//    		error /= turnPosition.size();
//    		
//    		if (error > 3 || error < -3/*navx.getYaw() < turnSetPoint - 3*/) {
//    			turndisplacement = error * 48.8;
//    			System.out.println("turndisplacement: " + turndisplacement);
//    			if (turndisplacement > 2200) {
//    				turndisplacement = 2200;
//    			}
//    			else if (turndisplacement < -2200) {
//    				turndisplacement = -2200;
//    			}
//    		}
//    		else {
//    			turndisplacement = 0;
//    		}
    		if (printTimerCount >= 10) {
//	    		System.out.println("Setpoint: " + turnController.getSetpoint());
//	    		System.out.println("Position: " + navx.getYaw());
//	    		System.out.println("Error: " + turnController.getError());
    		}
    		
    		leftMasterTalon.set(ControlMode.Velocity, -turndisplacement);
    		rightMasterTalon.set(ControlMode.Velocity, turndisplacement);
    	}
    	else if (currentMode == DriveTrainControlMode.OperatorControl) {
    		if (driverDamp) {
    			leftSpeedTarget = leftSpeedTarget > 2 ? 2 : leftSpeedTarget;
    			rightSpeedTarget = rightSpeedTarget > 2 ? 2 : rightSpeedTarget;
    			leftSpeedTarget = leftSpeedTarget < -2 ? -2 : leftSpeedTarget;
    			rightSpeedTarget = rightSpeedTarget < -2 ? -2 : rightSpeedTarget;
    		}
    		
    		// Auto shift policy versus manual
	    	if (doAutoShift) {
	    		// Get average speeds of motors
	    		double currentLeftSpeed = Math.abs(encoderUnitsToFeetPerSec(leftSideAverageSpeedEncoder));
	    		double currentRightSpeed = Math.abs(encoderUnitsToFeetPerSec(rightSideAverageSpeedEncoder));
	    		
	    		// wanting LowGear forces low gear for driver override.
	    		if (wantedGear == Gear.LowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		// Shift up if both sides are above a threshold
	    		else if (currentLeftSpeed > 5 && currentRightSpeed > 5) {
	    			setGear(Gear.HighGear);
	    		}
	    		// Shift down if both sides are below a threshold
	    		else if (currentLeftSpeed < 4 && currentRightSpeed < 4) {
	    			setGear(Gear.LowGear);
	    		}
	    		// The thresholds should have distance between them to prevent rapid shifting between gears.
	    	}
	    	else {
	    		// Just use outside demands to decide gearing
	    		setGear(wantedGear);
	    	}
	    	
	    	double change = navx.getYaw() - lastAngle;
	    	lastAngle = navx.getYaw();
	    	
	    	if (Math.abs(leftSpeedTarget - rightSpeedTarget) > 0) {
	    		turndisplacement = 0;
	    		rotating = true;
    			rotateTimeout = false;
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
    			opTurnTimer.stop();
    			opTurnTimer.reset();
	    	}
	    	else {
	    		if (rotating) {
	    			opTurnTimer.start();
		    		rotating = false;
		    		rotateTimeout = true;
			    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
			    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
	    			targetAngle = navx.getAngle();
	    			operatorStraightener.setSetpoint(targetAngle);
	    			System.out.println("rotating");
		    	}
	    		else if (rotateTimeout && opTurnTimer.hasPeriodPassed(2)) {
	    			targetAngle = navx.getAngle();
	    			operatorStraightener.setSetpoint(targetAngle);
	    			rotateTimeout = false;
			    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
			    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
			    	System.out.println("rotated");
	    		}
	    		else if (!rotateTimeout) {
	    			opTurnTimer.stop();
	    			opTurnTimer.reset();
		    		leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget) - opTurnDisplacement);
				    rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget) + opTurnDisplacement);
		    		
		    		operatorStraightener.setSetpoint(targetAngle);
	    		}
	    		else {
			    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
			    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
	    		}
	    	}
	    	
	    	// TODO This doesn't do anything, maybe make it do something or throw it out, IDK.
//	    	if (currentGear == Gear.LowGear) {
//		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget) - opTurnDisplacement);
//		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget) + opTurnDisplacement);
//	    	}
//	    	else if (currentGear == Gear.HighGear) {
//		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
//		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
//	    	}
    	}
    	else if(currentMode == DriveTrainControlMode.Stopped) {
    		leftMasterTalon.stopMotor();
    		rightMasterTalon.stopMotor();
    	}
        
    	// Every 10 loops output debug info and desired driver info.
    	if (printTimerCount >= 10) {
    		publishVelocityToShuffleBoard();
    		SmartDashboard.putNumber("Left Range", getLeftRange());
    		SmartDashboard.putNumber("Right Range", getRightRange());

//    		System.out.println("leftSet: " + leftSpeedTarget);
//    		System.out.println("turn: " + opTurnDisplacement);
//    		
//    		System.out.println("rotating: " + rotating);
//    		System.out.println("diff: " + Math.abs(leftSpeedTarget - rightSpeedTarget));
//    		System.out.println("targetAngle: " + targetAngle);
//    		System.out.println("angle: " + navx.getYaw());
    		
    		printTimerCount = 0;
    	}
    	else {
    		printTimerCount++;
    	}
    	
//    	navx.getAngle();
    	
    	// Calculates average velocities
    	
    	// If the buffers are full, do the calculations otherwise, just keep filling them.
    	if (leftSideVelocityBuffer.size() == 20 && rightSideVelocityBuffer.size() == 20) {
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		leftSideVelocityBuffer.removeLast();
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		leftSideAverageSpeedEncoder = 0;
    		for (int i : leftSideVelocityBuffer) {
    			leftSideAverageSpeedEncoder += i;
    		}
    		leftSideAverageSpeedEncoder /= 20;
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		rightSideVelocityBuffer.removeLast();
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		rightSideAverageSpeedEncoder = 0;
    		for (int i : rightSideVelocityBuffer) {
    			rightSideAverageSpeedEncoder += i;
    		}
    		rightSideAverageSpeedEncoder /= 20;
    	}
    	else {
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    	}
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void setControlMode(DriveTrainControlMode mode) {
    	if (mode == DriveTrainControlMode.OperatorControl) {
    		targetAngle = navx.getAngle();
    		operatorStraightener.setSetpoint(targetAngle);
	    	leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    	}
    	else if (mode == DriveTrainControlMode.DriveForward) {
    		// Changing Talon mode
	    	leftMasterTalon.set(ControlMode.MotionMagic, 0);
	    	rightMasterTalon.set(ControlMode.MotionMagic, 0);
	    	// Changing to motion magic PID profile
	    	leftMasterTalon.selectProfileSlot(2, 0);
	    	rightMasterTalon.selectProfileSlot(2, 0);
	    	// Update state
	    	inMotionMagicMode = true;
	    	// Currently only using lowGear for auto movement. Will require more complexety to change.
	    	setGear(Gear.LowGear);
	    	zeroEncoderPosition();
    	}
    	else if (mode == DriveTrainControlMode.TurnInPlace) {
    		leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    	}
    	currentMode = mode;
    }
    
    public DriveTrainControlMode getControlMode() {
    	return currentMode;
    }
    
    private boolean driverBlock = false;
    
    public void blockDriver(boolean value) {
    	driverBlock = value;
    }
    
    public boolean getDriverBlock() {
    	return driverBlock;
    }
    
    public Gear getCurrentGear() {
    	return currentGear;
    }
    
    public double getLeftError() {
    	return leftMasterTalon.getClosedLoopError(0);
    }
    
    public double getRightError() {
    	return rightMasterTalon.getClosedLoopError(0);
    }
    
    public double getLeftPosition() {
    	return leftMasterTalon.getSelectedSensorPosition(0) - leftPositionZero;
//    	return leftMasterTalon.getSelectedSensorPosition(0);
    }
    
    public double getRightPosition() {
    	return rightMasterTalon.getSelectedSensorPosition(0) - rightPositionZero;
//    	return rightMasterTalon.getSelectedSensorPosition(0);
    }
    
    public double getLeftTarget() {
    	return leftMasterTalon.getClosedLoopTarget(0);
    }
    
    public double getRightTarget() {
    	return rightMasterTalon.getClosedLoopTarget(0);
    }

    public double getLeftRange() {
    	double distanceCM = leftRangeFinder.getAverageVoltage() / (5.0 / 1024.0);
    	return distanceCM / (500.0 / 197.0); // Convert to inches
    }
    
    public double getRightRange() {
    	double distanceCM = rightRangeFinder.getAverageVoltage() / (5.0 / 1024.0);
    	return distanceCM / (500.0 / 197.0); // Convert to inches
    }
    
    //====================================================
    // Motion Magic Control Methods
    
    // TODO concern about compressor voltage draw affecting accuracy?
    
    /**
     * Feed the talons a target distance to travel in feet. Can be called every loop, maybe has to been, IDK.
     * Before starting a movement, setMotionMagicMode() and zeroEncoderPosition() should be called to ensure proper functioning.
     * @param targetFt Position to be traveled to in feet
     */
    public void setMotionMagicTargetFt(double targetFt) {
    	motionMagicSetPoint = -feetToEncoderUnits(targetFt);
    }
    
    public void setMotionMagicTarget(int target) {
    	motionMagicSetPoint = -target;
    }
    
    public void startMotion() {
    	if (currentMode != DriveTrainControlMode.DriveForward)
    	{
    		System.out.println("Error: Motion Control attempted");
    	}
    	else {
    		zeroEncoderPosition();
    		motionRunning = true;
    	}
    }
    
    public void stopMotion() {
    	if (currentMode != DriveTrainControlMode.DriveForward)
    	{
    		System.out.println("Error: Motion Control attempted");
    	}
    	else {
    		motionRunning = false;
    	}
    }

    /**
     * Returns true when motion has completed and drive train is stopped.
     * @return true when done.
     */
    public boolean hasReachedMotionTarget() {
//    	int leftErrorAbs = Math.abs(leftMasterTalon.getClosedLoopError(0));
//    	int rightErrorAbs = Math.abs(rightMasterTalon.getClosedLoopError(0));
    	int leftErrorAbs = Math.abs(motionMagicSetPoint - (leftMasterTalon.getSelectedSensorPosition(0) - leftPositionZero));
    	int rightErrorAbs = Math.abs(motionMagicSetPoint - (rightMasterTalon.getSelectedSensorPosition(0) - rightPositionZero));
    	return (leftErrorAbs < allowableError) && (rightErrorAbs < allowableError);
    }
    
    public boolean motionRunning() {
    	return motionRunning;
    }
    //====================================================
    // Auto Turn Methods
    
    /**
     * Give the target degrees to turn. Zero is the current position. TODO Positive turns _____, negative turns _____.
     * @param degrees
     */
    public void setTurnTarget(double degrees) {
    	
    	turnSetPoint = ((degrees + navx.getYaw()) % 360);
    	if (turnSetPoint > 180) {
    		turnSetPoint -= 360;
    	}
    	else if (turnSetPoint < -180) {
    		turnSetPoint += 360;
    	}
    }
    
    /**
     * Called to begin the turn to set point. System will not before this is started.
     */
    public void startTurn() {
    	if (currentMode != DriveTrainControlMode.TurnInPlace)
    	{
    		System.out.println("Error: Turn Control attempted");
    	}
    	else {
    		turnRunning = true;
    		turnController.setSetpoint(turnSetPoint);
    		turnController.enable();
    	}
    }
    
    /**
     * Called to halt a turn during it's motion or make sure it is stopped at the end. Does not ensure a motionless robot.
     */
    public void stopTurn() {
    	if (currentMode != DriveTrainControlMode.TurnInPlace)
    	{
    		System.out.println("Error: Turn Control attempted");
    	}
    	else {
    		turnRunning = false;
    		turnController.disable();
    	}
    }
    
    public boolean hasReachedTurnTarget() {
		return turnController.onTarget();
    }

    public double getNavxReading() {
    	return navx.getYaw();
    }
    
    public double getTurnError() {
    	return turnSetPoint - navx.getYaw();
    }
    
    //====================================================
    // Normal Drive Control Methods
    
    /**
     * Called to switch in and out of auto shift
     * @param value
     */
    public void setAutoShift(boolean value) {
    	doAutoShift = value;
    }
    
    /**
     * Called to change target gear. DriveSystem will shift when in driver control.
     * @param gear to be shifted to.
     */
    public void setWantedGear(Gear gear) {
    	wantedGear = gear;
    }
    
    public void setDamp(boolean value) {
    	driverDamp = value;
    }
    
    public void updateTargetAngle() {
    	targetAngle = navx.getAngle();
    }

    /**
     * Sets DriveSystem target speeds
     * @param leftSpeed Wanted velocity for left side in feet per second.
     * @param rightSpeed Wanted velocity for right side in feet per second.
     */
    public void drive(double leftSpeed, double rightSpeed) {
    	if (currentMode != DriveTrainControlMode.OperatorControl) {
    		System.out.println("Error: Operator Control Attempted");
    	}
    	else {
    		leftSpeedTarget = leftSpeed;
    		rightSpeedTarget = rightSpeed;
    	}
    }
    

    //====================================================
    // Utility Methods
    
    public static double encoderUnitsToFeetPerSec(int encoderUnits) {
    	return (((encoderUnits * 10) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetPerSecToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096) / 10;
    }
    
    public static double encoderUnitsToFeet(int encoderUnits) {
    	return (((encoderUnits) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096);
    }
    

    //====================================================
    // System Components Control Methods
    
    private void setGear(Gear value) {
    	if (value == Gear.LowGear && currentGear != Gear.LowGear) {
    		shifter.set(Value.kForward);
    		leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    		currentGear = Gear.LowGear;
    	}
    	else if (value == Gear.HighGear && currentGear != Gear.HighGear) {
    		shifter.set(Value.kReverse);
	    	leftMasterTalon.selectProfileSlot(1, 0);
	    	rightMasterTalon.selectProfileSlot(1, 0);
    		currentGear = Gear.HighGear;
    	}
    }

    private void zeroEncoderPosition() {
//    	leftMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
//    	ErrorCode code = rightMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
//    	System.out.println(code);
    	leftPositionZero = leftMasterTalon.getSelectedSensorPosition(0);
    	rightPositionZero = rightMasterTalon.getSelectedSensorPosition(0);
    }

    //====================================================
    // Debug Methods
    
    public void publishVelocityToShuffleBoard() {
    	SmartDashboard.putNumber("Left Side Velocity", encoderUnitsToFeetPerSec(leftMasterTalon.getSelectedSensorVelocity(0)));
    	SmartDashboard.putNumber("Right Side Velocity", encoderUnitsToFeetPerSec(rightMasterTalon.getSelectedSensorVelocity(0)));
    }
    
    public void publishTopSpeed() {
    	topLeft = topLeft < leftMasterTalon.getSelectedSensorVelocity(0) ? leftMasterTalon.getSelectedSensorVelocity(0) : topLeft;
    	topRight = topRight < rightMasterTalon.getSelectedSensorVelocity(0) ? rightMasterTalon.getSelectedSensorVelocity(0) : topRight;
    	SmartDashboard.putNumber("Top Left Side Velocity", topLeft);
    	SmartDashboard.putNumber("Top Right Side Velocity", topRight);
    }
}

