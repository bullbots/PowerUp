// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1891.PowerUp.subsystems;

import java.util.LinkedList;

import org.usfirst.frc1891.PowerUp.RobotMap;
import org.usfirst.frc1891.PowerUp.commands.*;

import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveSystem extends Subsystem {
	
	public enum Gear {
		LowGear,
		HighGear
	}

	/**
	 * 
	 */
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX leftMasterTalon = RobotMap.driveSystemLeftMasterTalon;
    private final WPI_TalonSRX leftSlaveTalon = RobotMap.driveSystemLeftSlaveTalon;
    private final WPI_TalonSRX rightMasterTalon = RobotMap.driveSystemRightMasterTalon;
    private final WPI_TalonSRX rightSlaveTalon = RobotMap.driveSystemRightSlaveTalon;
    
    private DoubleSolenoid shifter;
    
    /**
     * Variable to keep track of how the driver wants shifting to be controlled.
     */
    private boolean doAutoShift = false;
    /**
     * Set when we want to change gears, gear change decision made based off of this. 
     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
     */
    private boolean wantsLowGear = true;
    /**
     * Set when we want to change gears, gear change decision made based off of this. 
     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
     */
    private boolean wantsHighGear = false;
    /**
     * State Variable for position control of drivetrain for auto driving (using the motion magic mode on
     * TalonSRXs) versus normal operator control.
     */
    private boolean inMotionMagicMode = false;
    
    /**
     * State Variable for current physical gearing.
     */
    public Gear currentGear = Gear.LowGear;
    
    
    /*
     * Members used to determine average speed of either side of drive. Used for autoshifting.
     */
    private LinkedList<Integer> leftSideVelocityBuffer = new LinkedList<Integer>();
    private LinkedList<Integer> rightSideVelocityBuffer = new LinkedList<Integer>();
    private int leftSideAverageSpeedEncoder;
    private int rightSideAverageSpeedEncoder;
    
    // DriveTrain Constant values
    public static final int leftSideLowGearTopSpeed = 12041;
    public static final int rightSideLowGearTopSpeed = 11682;
    public static final int leftSideHighGearTopSpeed = 24770;
    public static final int rightSideHighGearTopSpeed = 24482;
    
    public static final double leftSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideLowGearTopSpeed);
    public static final double rightSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideLowGearTopSpeed);
    public static final double leftSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideHighGearTopSpeed);
    public static final double rightSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideHighGearTopSpeed);

    public static final int enforcedLowGearTopSpeed = 11000;
    public static final int enforcedHighGearTopSpeed = 24000;
    
    public static final double enforcedLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(11000);
    public static final double enforcedHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(24000);
    
	public static final double wheelDiameterFeet = 0.5;
	public static final double encoderRevsPerWheelRev = 7.5;
	
	private static final double allowableError = 200;
	
	public static final int maxLowGearAcceleration = enforcedLowGearTopSpeed / 2;
	
	// fields used for debug
	public int printTimerCount = 0;
    private int topLeft;
    private int topRight;
	public int motionMagicSetPoint;
	
	
	public DriveSystem() {
		shifter = new DoubleSolenoid(RobotMap.ShifterLowPort, RobotMap.ShifterHighPort);
		setGear(Gear.LowGear);
	}
    
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new JoystickDrive());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        
    	// Every 10 loops output debug info and desired driver info.
    	if (printTimerCount >= 10) {
    		publishVelocityToShuffleBoard();
    		printTimerCount = 0;
    	}
    	else {
    		printTimerCount++;
    	}
    	
    	// Calculates average velocities
    	
    	// If the buffers are full, do the calculations otherwise, just keep filling them.
    	if (leftSideVelocityBuffer.size() == 20 && rightSideVelocityBuffer.size() == 20) {
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		leftSideVelocityBuffer.removeLast();
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		leftSideAverageSpeedEncoder = 0;
    		for (int i : leftSideVelocityBuffer) {
    			leftSideAverageSpeedEncoder += i;
    		}
    		leftSideAverageSpeedEncoder /= 20;
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		rightSideVelocityBuffer.removeLast();
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		rightSideAverageSpeedEncoder = 0;
    		for (int i : rightSideVelocityBuffer) {
    			rightSideAverageSpeedEncoder += i;
    		}
    		rightSideAverageSpeedEncoder /= 20;
    	}
    	else {
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    	}
//    	publishTopSpeed();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    
    // Motion Magic Control Methods
    /**
     * Called when setting up for auto movement. Changes drive train state, 
     * cannot drive with drive() method when set true
     * @param value Whether or not we should be in motion magic mode.
     */
    public void setMotionMagicMode(boolean value) {
    	if (value) {
    		// Changing Talon mode
	    	leftMasterTalon.set(ControlMode.MotionMagic, 0);
	    	rightMasterTalon.set(ControlMode.MotionMagic, 0);
	    	// Changing to motion magic PID profile
	    	leftMasterTalon.selectProfileSlot(2, 0);
	    	rightMasterTalon.selectProfileSlot(2, 0);
	    	// Update state
	    	inMotionMagicMode = true;
	    	// Currently only using lowGear for auto movement. Will require more complexety to change.
	    	setGear(Gear.LowGear);
    	}
	    else {
	    	// Update state
	    	inMotionMagicMode = false;
	    }
    }
    
    /**
     * Feed the talons a target distance to travel in feet. Can be called every loop, maybe has to been, IDK.
     * Before starting a movement, setMotionMagicMode() and zeroEncoderPosition() should be called to ensure proper functioning.
     * @param targetFt Position to be traveled to in feet
     */
    public void setMotionMagicTargetFt(double targetFt) {
    	motionMagicSetPoint = feetToEncoderUnits(targetFt);
    	leftMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
    	rightMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
    }

    /**
     * Returns true when motion has completed and drive train is stopped.
     * @return true when done.
     */
    public boolean hasReachedMotionTarget() {
    	int leftErrorAbs = Math.abs(motionMagicSetPoint - leftMasterTalon.getSelectedSensorPosition(0));
    	int rightErrorAbs = Math.abs(motionMagicSetPoint - rightMasterTalon.getSelectedSensorPosition(0));
    	return (leftErrorAbs < allowableError) && (rightErrorAbs < allowableError);
    }
    
    public double getLeftError() {
    	return leftMasterTalon.getClosedLoopError(0);
    }
    
    public double getRightError() {
    	return rightMasterTalon.getClosedLoopError(0);
    }
    
    // Normal Drive Control Methods
    /**
     * Called to switch in and out of auto shift
     * @param value
     */
    public void setAutoShift(boolean value) {
    	doAutoShift = value;
    }
    
    /**
     * Called when low gear is wanted. Setting true guarantees change to low gear, false leaves gear in prior state.
     * @param value
     */
    public void setWantsLowGear(boolean value) {
    	wantsLowGear = value;
    }
    
    /**
     * Called when high gear is wanted. Setting true may not give high gear, as set low gear gets priority.
     * False leaves gear in prior state.
     * @param value
     */
    public void setWantsHighGear(boolean value) {
    	wantsHighGear = value;
    }

    /**
     * Called every loop of operator control. Will do nothing if called in motion magic mode. 
     * @param leftSpeed Wanted velocity for left side in feet per second.
     * @param rightSpeed Wanted velocity for right side in feet per second.
     */
    public void drive(double leftSpeed, double rightSpeed) {
    	
    	// if in motion magic mode, do nothing, complain in the console.
    	if (inMotionMagicMode) {
    		System.out.println("Error: drive method is being called during motion magic control");
    	}
    	else {
    		// Auto shift policy versus manual
	    	if (doAutoShift) {
	    		// Get average speeds of motors
	    		double currentLeftSpeed = Math.abs(encoderUnitsToFeetPerSec(leftSideAverageSpeedEncoder));
	    		double currentRightSpeed = Math.abs(encoderUnitsToFeetPerSec(rightSideAverageSpeedEncoder));
	    		
	    		// wantsLowGear forces low gear for driver override.
	    		if (wantsLowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		// Shift up if both sides are above a threshold
	    		else if (currentLeftSpeed > 5 && currentRightSpeed > 5) {
	    			setGear(Gear.HighGear);
	    		}
	    		// Shift down if both sides are below a threshold
	    		else if (currentLeftSpeed < 4 && currentRightSpeed < 4) {
	    			setGear(Gear.LowGear);
	    		}
	    		// The thresholds should have distance between them to prevent rapid shifting between gears.
	    	}
	    	else {
	    		// Just use outside demands to decide gearing
	    		// Low gear has priority
	    		if (wantsLowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		else if (wantsHighGear) {
	    			setGear(Gear.HighGear);
	    		}
	    	}
	    	
	    	// TODO This doesn't do anything, maybe make it do something or throw it out, IDK.
	    	if (currentGear == Gear.LowGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeed));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeed));
	    	}
	    	else if (currentGear == Gear.HighGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeed));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeed));
	    	}
    	}
    }
    
    
    // Utility Methods
    public static double encoderUnitsToFeetPerSec(int encoderUnits) {
    	return (((encoderUnits * 10) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetPerSecToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096) / 10;
    }
    
    public static double encoderUnitsToFeet(int encoderUnits) {
    	return (((encoderUnits) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096);
    }
    
    private void setGear(Gear value) {
    	if (value == Gear.LowGear && currentGear != Gear.LowGear) {
    		shifter.set(Value.kForward);
    		leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    		currentGear = Gear.LowGear;
    	}
    	else if (value == Gear.HighGear && currentGear != Gear.HighGear) {
    		shifter.set(Value.kReverse);
	    	leftMasterTalon.selectProfileSlot(1, 0);
	    	rightMasterTalon.selectProfileSlot(1, 0);
    		currentGear = Gear.HighGear;
    	}
    }

    public void zeroEncoderPosition() {
    	leftMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    	rightMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    }

    // Debug Methods
    public void publishVelocityToShuffleBoard() {
    	SmartDashboard.putNumber("Left Side Velocity", encoderUnitsToFeetPerSec(leftMasterTalon.getSelectedSensorVelocity(0)));
    	SmartDashboard.putNumber("Right Side Velocity", encoderUnitsToFeetPerSec(rightMasterTalon.getSelectedSensorVelocity(0)));
    }
    
    public void publishTopSpeed() {
    	topLeft = topLeft < leftMasterTalon.getSelectedSensorVelocity(0) ? leftMasterTalon.getSelectedSensorVelocity(0) : topLeft;
    	topRight = topRight < rightMasterTalon.getSelectedSensorVelocity(0) ? rightMasterTalon.getSelectedSensorVelocity(0) : topRight;
    	SmartDashboard.putNumber("Top Left Side Velocity", topLeft);
    	SmartDashboard.putNumber("Top Right Side Velocity", topRight);
    }
}

