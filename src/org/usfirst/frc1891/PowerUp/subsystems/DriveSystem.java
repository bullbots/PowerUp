// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1891.PowerUp.subsystems;

import java.util.LinkedList;

import org.usfirst.frc1891.PowerUp.RobotMap;
import org.usfirst.frc1891.PowerUp.commands.*;

import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveSystem extends Subsystem {
	
	public enum Gear {
		LowGear,
		HighGear
	}

	/**
	 * 
	 */
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX leftMasterTalon = RobotMap.driveSystemLeftMasterTalon;
    private final WPI_TalonSRX leftSlaveTalon = RobotMap.driveSystemLeftSlaveTalon;
    private final WPI_TalonSRX rightMasterTalon = RobotMap.driveSystemRightMasterTalon;
    private final WPI_TalonSRX rightSlaveTalon = RobotMap.driveSystemRightSlaveTalon;
    
    private DoubleSolenoid shifter;
    
    private boolean doAutoShift = false;
    private boolean wantsLowGear = true;
    private boolean wantsHighGear = false;
    private boolean inMotionMagicMode = false;
    
    public Gear currentGear = Gear.LowGear;
    
    
    public LinkedList<Integer> leftSideVelocityBuffer = new LinkedList<Integer>();
    public LinkedList<Integer> rightSideVelocityBuffer = new LinkedList<Integer>();
    public int leftSideAverageSpeedEncoder;
    public int rightSideAverageSpeedEncoder;
    
    // DriveTrain Constant values
    public static final int leftSideLowGearTopSpeed = 12041;
    public static final int rightSideLowGearTopSpeed = 11682;
    public static final int leftSideHighGearTopSpeed = 24770;
    public static final int rightSideHighGearTopSpeed = 24482;
    
    public static final double leftSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideLowGearTopSpeed);
    public static final double rightSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideLowGearTopSpeed);
    public static final double leftSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideHighGearTopSpeed);
    public static final double rightSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideHighGearTopSpeed);

    public static final int enforcedLowGearTopSpeed = 11000;
    public static final int enforcedHighGearTopSpeed = 24000;
    
    public static final double enforcedLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(11000);
    public static final double enforcedHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(24000);
    
	public static final double wheelDiameterFeet = 0.5;
	public static final double encoderRevsPerWheelRev = 7.5;
	
	private static final double allowableError = 200;
	
	public static int maxLowGearAcceleration = enforcedLowGearTopSpeed / 2;
	
	// fields used for debug
	public int printTimerCount = 0;
    private int topLeft;
    private int topRight;
	public int motionMagicSetPoint;
	
	
	public DriveSystem() {
		shifter = new DoubleSolenoid(RobotMap.ShifterLowPort, RobotMap.ShifterHighPort);
		setGear(Gear.LowGear);
	}
    
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new JoystickDrive());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	if (printTimerCount >= 10) {
    		publishVelocityToShuffleBoard();
    		printTimerCount = 0;
    	}
    	else {
    		printTimerCount++;
    	}
    	
    	if (leftSideVelocityBuffer.size() == 20 && rightSideVelocityBuffer.size() == 20) {
    		leftSideVelocityBuffer.removeLast();
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		leftSideAverageSpeedEncoder = 0;
    		for (int i : leftSideVelocityBuffer) {
    			leftSideAverageSpeedEncoder += i;
    		}
    		leftSideAverageSpeedEncoder /= 20;
    		
    		rightSideVelocityBuffer.removeLast();
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    		rightSideAverageSpeedEncoder = 0;
    		for (int i : rightSideVelocityBuffer) {
    			rightSideAverageSpeedEncoder += i;
    		}
    		rightSideAverageSpeedEncoder /= 20;
    	}
    	else {
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    	}
//    	publishTopSpeed();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    
    // Motion Magic Control Methods
    public void setMotionMagicMode(boolean value) {
    	if (value) {
	    	leftMasterTalon.set(ControlMode.MotionMagic, 0);
	    	rightMasterTalon.set(ControlMode.MotionMagic, 0);
	    	leftMasterTalon.selectProfileSlot(2, 0);
	    	rightMasterTalon.selectProfileSlot(2, 0);
	    	inMotionMagicMode = true;
	    	setGear(Gear.LowGear);
    	}
	    else {
	    	inMotionMagicMode = false;
	    }
    }
    
    public void setMotionMagicTargetFt(double targetFt) {
    	motionMagicSetPoint = feetToEncoderUnits(targetFt);
    	leftMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
    	rightMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
    }

    public boolean hasReachedMotionTarget() {
    	int leftErrorAbs = Math.abs(motionMagicSetPoint - leftMasterTalon.getSelectedSensorPosition(0));
    	int rightErrorAbs = Math.abs(motionMagicSetPoint - rightMasterTalon.getSelectedSensorPosition(0));
    	return (leftErrorAbs < allowableError) && (rightErrorAbs < allowableError);
    }
    
    public double getLeftError() {
    	return leftMasterTalon.getClosedLoopError(0);
    }
    
    public double getRightError() {
    	return rightMasterTalon.getClosedLoopError(0);
    }
    
    // Normal Drive Control Methods
    public void setAutoShift(boolean value) {
    	doAutoShift = value;
    }
    
    public void setWantsLowGear(boolean value) {
    	wantsLowGear = value;
    }
    
    public void setWantsHighGear(boolean value) {
    	wantsHighGear = value;
    }

    public void drive(double leftSpeed, double rightSpeed) {
    	if (inMotionMagicMode) {
    		System.out.println("Error: drive method is being called during motion magic control");
    	}
    	else {
	    	if (doAutoShift) {
	    		double currentLeftSpeed = Math.abs(encoderUnitsToFeetPerSec(leftSideAverageSpeedEncoder));
	    		double currentRightSpeed = Math.abs(encoderUnitsToFeetPerSec(rightSideAverageSpeedEncoder));
	    		if (wantsLowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		else if (currentLeftSpeed > 5 && currentRightSpeed > 5) {
	    			setGear(Gear.HighGear);
	    		}
	    		else if (currentLeftSpeed < 4 && currentRightSpeed < 4) {
	    			setGear(Gear.LowGear);
	    		}
	    	}
	    	else {
	    		if (wantsLowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		else if (wantsHighGear) {
	    			setGear(Gear.HighGear);
	    		}
	    	}
	    	
	    	if (currentGear == Gear.LowGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeed));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeed));
	    	}
	    	else if (currentGear == Gear.HighGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeed));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeed));
	    	}
    	}
    }
    
    
    // Utility Methods
    public static double encoderUnitsToFeetPerSec(int encoderUnits) {
    	return (((encoderUnits * 10) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetPerSecToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096) / 10;
    }
    
    public static double encoderUnitsToFeet(int encoderUnits) {
    	return (((encoderUnits) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096);
    }
    
    private void setGear(Gear value) {
    	if (value == Gear.LowGear && currentGear != Gear.LowGear) {
    		shifter.set(Value.kForward);
    		leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    		currentGear = Gear.LowGear;
    	}
    	else if (value == Gear.HighGear && currentGear != Gear.HighGear) {
    		shifter.set(Value.kReverse);
	    	leftMasterTalon.selectProfileSlot(1, 0);
	    	rightMasterTalon.selectProfileSlot(1, 0);
    		currentGear = Gear.HighGear;
    	}
    }

    public void zeroEncoderPosition() {
    	leftMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    	rightMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    }

    // Debug Methods
    public void publishVelocityToShuffleBoard() {
    	SmartDashboard.putNumber("Left Side Velocity", encoderUnitsToFeetPerSec(leftMasterTalon.getSelectedSensorVelocity(0)));
    	SmartDashboard.putNumber("Right Side Velocity", encoderUnitsToFeetPerSec(rightMasterTalon.getSelectedSensorVelocity(0)));
    }
    
    public void publishTopSpeed() {
    	topLeft = topLeft < leftMasterTalon.getSelectedSensorVelocity(0) ? leftMasterTalon.getSelectedSensorVelocity(0) : topLeft;
    	topRight = topRight < rightMasterTalon.getSelectedSensorVelocity(0) ? rightMasterTalon.getSelectedSensorVelocity(0) : topRight;
    	SmartDashboard.putNumber("Top Left Side Velocity", topLeft);
    	SmartDashboard.putNumber("Top Right Side Velocity", topRight);
    }
}

