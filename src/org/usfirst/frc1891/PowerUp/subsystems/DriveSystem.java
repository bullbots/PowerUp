// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1891.PowerUp.subsystems;

import java.util.LinkedList;

import org.usfirst.frc1891.PowerUp.RobotMap;
import org.usfirst.frc1891.PowerUp.commands.*;

import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;



/**
 *
 */
public class DriveSystem extends Subsystem {
	
	public enum Gear {
		LowGear,
		HighGear
	}
	
	public enum DriveTrainControlMode {
		OperatorControl,
		DriveForward,
		TurnInPlace,
		Stopped
	}

    private final WPI_TalonSRX leftMasterTalon = RobotMap.driveSystemLeftMasterTalon;
    private final WPI_TalonSRX leftSlaveTalon = RobotMap.driveSystemLeftSlaveTalon;
    private final WPI_TalonSRX rightMasterTalon = RobotMap.driveSystemRightMasterTalon;
    private final WPI_TalonSRX rightSlaveTalon = RobotMap.driveSystemRightSlaveTalon;
    
    private final DoubleSolenoid shifter;
    
    private final AHRS navx = RobotMap.ahrs;
    
    private DriveTrainControlMode currentMode = DriveTrainControlMode.Stopped;
    /**
     * Variable to keep track of how the driver wants shifting to be controlled.
     */
    private boolean doAutoShift = false;
//    /**
//     * Set when we want to change gears, gear change decision made based off of this. 
//     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
//     */
//    private boolean wantsLowGear = true;
//    /**
//     * Set when we want to change gears, gear change decision made based off of this. 
//     * Low gear gets priority when both wantsLowGear and wantsHighGear are true.
//     */
//    private boolean wantsHighGear = false;
    
    private Gear wantedGear = Gear.LowGear;
    
    private double leftSpeedTarget = 0;
    private double rightSpeedTarget = 0;
    /**
     * State Variable for position control of drivetrain for auto driving (using the motion magic mode on
     * TalonSRXs) versus normal operator control.
     */
    private boolean inMotionMagicMode = false;
    
    private boolean motionRunning = false;
	private int motionMagicSetPoint = 0;
	
    private boolean turnRunning = false;
    private double turnSetPoint = 0;
    private double turndisplacement = 0;
    private PIDController turnController;
    
    /**
     * State Variable for current physical gearing.
     */
    private Gear currentGear = Gear.LowGear;
    
    
    /*
     * Members used to determine average speed of either side of drive. Used for autoshifting.
     */
    private LinkedList<Integer> leftSideVelocityBuffer = new LinkedList<Integer>();
    private LinkedList<Integer> rightSideVelocityBuffer = new LinkedList<Integer>();
    private int leftSideAverageSpeedEncoder;
    private int rightSideAverageSpeedEncoder;
    
    
    
    // DriveTrain Constant values
    public static final int leftSideLowGearTopSpeed = 12041;
    public static final int rightSideLowGearTopSpeed = 11682;
    public static final int leftSideHighGearTopSpeed = 24770;
    public static final int rightSideHighGearTopSpeed = 24482;
    
    public static final double leftSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideLowGearTopSpeed);
    public static final double rightSideLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideLowGearTopSpeed);
    public static final double leftSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(leftSideHighGearTopSpeed);
    public static final double rightSideHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(rightSideHighGearTopSpeed);

    public static final int enforcedLowGearTopSpeed = 11000;
    public static final int enforcedHighGearTopSpeed = 24000;
    
    public static final double enforcedLowGearTopSpeedFeet = encoderUnitsToFeetPerSec(11000);
    public static final double enforcedHighGearTopSpeedFeet = encoderUnitsToFeetPerSec(24000);
    
	public static final double wheelDiameterFeet = 0.5;
	public static final double encoderRevsPerWheelRev = 7.5;
	
	private static final double allowableError = 2000;
	
	public static final int maxLowGearAcceleration = enforcedLowGearTopSpeed / 2;
	
	
	
	// fields used for debug
	public int printTimerCount = 0;
    private int topLeft;
    private int topRight;
	
    private class TurnSource implements PIDSource {

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			// TODO check feedback, maybe needs to be complicated
			return navx.getYaw();
		}
    	
    }
	
	public DriveSystem() {
		shifter = new DoubleSolenoid(RobotMap.ShifterLowPort, RobotMap.ShifterHighPort);
		setGear(Gear.LowGear);
		
		turnController = new PIDController(0, 0, 0, new TurnSource(), new PIDOutput() {
			public void pidWrite(double output) {
				turndisplacement = output;
			}
		});
		turnController.setInputRange(-180, 180);
		turnController.setOutputRange(-3, 3);
		turnController.setAbsoluteTolerance(3);
		turnController.setContinuous();
	}
    
    

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new JoystickDrive());
    }

    @Override
    public void periodic() {
    	// motion magic check
    	if (currentMode == DriveTrainControlMode.DriveForward && motionRunning) {
        	leftMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
        	rightMasterTalon.set(ControlMode.MotionMagic, motionMagicSetPoint);
    	} 
    	// Turn check
    	else if (currentMode == DriveTrainControlMode.TurnInPlace && turnRunning) {
    		leftMasterTalon.set(ControlMode.Velocity, turndisplacement);
    		rightMasterTalon.set(ControlMode.Velocity, -turndisplacement);
    	}
    	else if (currentMode == DriveTrainControlMode.OperatorControl) {
    		// Auto shift policy versus manual
	    	if (doAutoShift) {
	    		// Get average speeds of motors
	    		double currentLeftSpeed = Math.abs(encoderUnitsToFeetPerSec(leftSideAverageSpeedEncoder));
	    		double currentRightSpeed = Math.abs(encoderUnitsToFeetPerSec(rightSideAverageSpeedEncoder));
	    		
	    		// wanting LowGear forces low gear for driver override.
	    		if (wantedGear == Gear.LowGear) {
	    			setGear(Gear.LowGear);
	    		}
	    		// Shift up if both sides are above a threshold
	    		else if (currentLeftSpeed > 5 && currentRightSpeed > 5) {
	    			setGear(Gear.HighGear);
	    		}
	    		// Shift down if both sides are below a threshold
	    		else if (currentLeftSpeed < 4 && currentRightSpeed < 4) {
	    			setGear(Gear.LowGear);
	    		}
	    		// The thresholds should have distance between them to prevent rapid shifting between gears.
	    	}
	    	else {
	    		// Just use outside demands to decide gearing
	    		setGear(wantedGear);
	    	}
	    	
	    	// TODO This doesn't do anything, maybe make it do something or throw it out, IDK.
	    	if (currentGear == Gear.LowGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
	    	}
	    	else if (currentGear == Gear.HighGear) {
		    	leftMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(leftSpeedTarget));
		    	rightMasterTalon.set(ControlMode.Velocity, feetPerSecToEncoderUnits(rightSpeedTarget));
	    	}
    	}
    	else if(currentMode == DriveTrainControlMode.Stopped) {
    		leftMasterTalon.stopMotor();
    		rightMasterTalon.stopMotor();
    	}
        
    	// Every 10 loops output debug info and desired driver info.
    	if (printTimerCount >= 10) {
    		publishVelocityToShuffleBoard();
    		SmartDashboard.putNumber("left position: ", getLeftPosition());
    		SmartDashboard.putNumber("right position: ", getRightPosition());
    		
    		SmartDashboard.putNumber("left error", getLeftError());
    		SmartDashboard.putNumber("right error", getRightError());
    		
    		printTimerCount = 0;
    	}
    	else {
    		printTimerCount++;
    	}
    	
//    	navx.getAngle();
    	
    	// Calculates average velocities
    	
    	// If the buffers are full, do the calculations otherwise, just keep filling them.
    	if (leftSideVelocityBuffer.size() == 20 && rightSideVelocityBuffer.size() == 20) {
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		leftSideVelocityBuffer.removeLast();
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		leftSideAverageSpeedEncoder = 0;
    		for (int i : leftSideVelocityBuffer) {
    			leftSideAverageSpeedEncoder += i;
    		}
    		leftSideAverageSpeedEncoder /= 20;
    		
    		// Using buffer as a queue, remove oldest measurement and add newest.
    		rightSideVelocityBuffer.removeLast();
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    		
    		// Calculate the average
    		rightSideAverageSpeedEncoder = 0;
    		for (int i : rightSideVelocityBuffer) {
    			rightSideAverageSpeedEncoder += i;
    		}
    		rightSideAverageSpeedEncoder /= 20;
    	}
    	else {
    		leftSideVelocityBuffer.addFirst(leftMasterTalon.getSelectedSensorVelocity(0));
    		rightSideVelocityBuffer.addFirst(rightMasterTalon.getSelectedSensorVelocity(0));
    	}
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void setControlMode(DriveTrainControlMode mode) {
    	if (mode == DriveTrainControlMode.OperatorControl) {
    		
    	}
    	else if (mode == DriveTrainControlMode.DriveForward) {
    		// Changing Talon mode
	    	leftMasterTalon.set(ControlMode.MotionMagic, 0);
	    	rightMasterTalon.set(ControlMode.MotionMagic, 0);
	    	// Changing to motion magic PID profile
	    	leftMasterTalon.selectProfileSlot(2, 0);
	    	rightMasterTalon.selectProfileSlot(2, 0);
	    	// Update state
	    	inMotionMagicMode = true;
	    	// Currently only using lowGear for auto movement. Will require more complexety to change.
	    	setGear(Gear.LowGear);
    	}
    	else if (mode == DriveTrainControlMode.TurnInPlace) {
    		
    	}
    	currentMode = mode;
    }
    
    public DriveTrainControlMode getControlMode() {
    	return currentMode;
    }
    
    public Gear getCurrentGear() {
    	return currentGear;
    }
    
    public double getLeftError() {
    	return leftMasterTalon.getClosedLoopError(0);
    }
    
    public double getRightError() {
    	return rightMasterTalon.getClosedLoopError(0);
    }
    
    public double getLeftPosition() {
    	return leftMasterTalon.getSelectedSensorPosition(0);
    }
    
    public double getRightPosition() {
    	return rightMasterTalon.getSelectedSensorPosition(0);
    }
    
    public double getLeftTarget() {
    	return leftMasterTalon.getClosedLoopTarget(0);
    }
    
    public double getRightTarget() {
    	return rightMasterTalon.getClosedLoopTarget(0);
    }

    //====================================================
    // Motion Magic Control Methods
    
    // TODO concern about compressor voltage draw affecting accuracy?
    
    /**
     * Feed the talons a target distance to travel in feet. Can be called every loop, maybe has to been, IDK.
     * Before starting a movement, setMotionMagicMode() and zeroEncoderPosition() should be called to ensure proper functioning.
     * @param targetFt Position to be traveled to in feet
     */
    public void setMotionMagicTargetFt(double targetFt) {
    	motionMagicSetPoint = -feetToEncoderUnits(targetFt);
    }
    
    public void startMotion() {
    	if (currentMode != DriveTrainControlMode.DriveForward)
    	{
    		System.out.println("Error: Motion Control attempted");
    	}
    	else {
    		zeroEncoderPosition();
    		motionRunning = true;
    	}
    }
    
    public void stopMotion() {
    	if (currentMode != DriveTrainControlMode.DriveForward)
    	{
    		System.out.println("Error: Motion Control attempted");
    	}
    	else {
    		motionRunning = false;
    	}
    }

    /**
     * Returns true when motion has completed and drive train is stopped.
     * @return true when done.
     */
    public boolean hasReachedMotionTarget() {
//    	int leftErrorAbs = Math.abs(leftMasterTalon.getClosedLoopError(0));
//    	int rightErrorAbs = Math.abs(rightMasterTalon.getClosedLoopError(0));
    	int leftErrorAbs = Math.abs(motionMagicSetPoint - leftMasterTalon.getSelectedSensorPosition(0));
    	int rightErrorAbs = Math.abs(motionMagicSetPoint - rightMasterTalon.getSelectedSensorPosition(0));
    	return (leftErrorAbs < allowableError) && (rightErrorAbs < allowableError);
    }
    
    //====================================================
    // Auto Turn Methods
    
    /**
     * Give the target degrees to turn. Zero is the current position. TODO Positive turns _____, negative turns _____.
     * @param degrees
     */
    public void setTurnTarget(double degrees) {
    	turnSetPoint = degrees;
    }
    
    /**
     * Called to begin the turn to set point. System will not before this is started.
     */
    public void startTurn() {
    	if (currentMode != DriveTrainControlMode.TurnInPlace)
    	{
    		System.out.println("Error: Turn Control attempted");
    	}
    	else {
    		turnRunning = true;
    		turnController.setSetpoint(turnSetPoint);
    		turnController.enable();
    	}
    }
    
    /**
     * Called to halt a turn during it's motion or make sure it is stopped at the end. Does not ensure a motionless robot.
     */
    public void stopTurn() {
    	if (currentMode != DriveTrainControlMode.TurnInPlace)
    	{
    		System.out.println("Error: Turn Control attempted");
    	}
    	else {
    		turnRunning = false;
    		turnController.disable();
    	}
    }
    
    public boolean hasReachedTurnTarget() {
		return turnController.onTarget();
    }

    //====================================================
    // Normal Drive Control Methods
    
    /**
     * Called to switch in and out of auto shift
     * @param value
     */
    public void setAutoShift(boolean value) {
    	doAutoShift = value;
    }
    
    /**
     * Called to change target gear. DriveSystem will shift when in driver control.
     * @param gear to be shifted to.
     */
    public void setWantedGear(Gear gear) {
    	wantedGear = gear;
    }

    /**
     * Sets DriveSystem target speeds
     * @param leftSpeed Wanted velocity for left side in feet per second.
     * @param rightSpeed Wanted velocity for right side in feet per second.
     */
    public void drive(double leftSpeed, double rightSpeed) {
    	if (currentMode != DriveTrainControlMode.OperatorControl) {
    		System.out.println("Error: Operator Control Attempted");
    	}
    	else {
    		leftSpeedTarget = leftSpeed;
    		rightSpeedTarget = rightSpeed;
    	}
    }
    

    //====================================================
    // Utility Methods
    
    public static double encoderUnitsToFeetPerSec(int encoderUnits) {
    	return (((encoderUnits * 10) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetPerSecToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096) / 10;
    }
    
    public static double encoderUnitsToFeet(int encoderUnits) {
    	return (((encoderUnits) / 4096) / encoderRevsPerWheelRev) * (wheelDiameterFeet * Math.PI);
    }
    
    public static int feetToEncoderUnits(double feetPerSec) {
    	return (int) (((encoderRevsPerWheelRev * feetPerSec) / (wheelDiameterFeet * Math.PI)) * 4096);
    }
    

    //====================================================
    // System Components Control Methods
    
    private void setGear(Gear value) {
    	if (value == Gear.LowGear && currentGear != Gear.LowGear) {
    		shifter.set(Value.kForward);
    		leftMasterTalon.selectProfileSlot(0, 0);
	    	rightMasterTalon.selectProfileSlot(0, 0);
    		currentGear = Gear.LowGear;
    	}
    	else if (value == Gear.HighGear && currentGear != Gear.HighGear) {
    		shifter.set(Value.kReverse);
	    	leftMasterTalon.selectProfileSlot(1, 0);
	    	rightMasterTalon.selectProfileSlot(1, 0);
    		currentGear = Gear.HighGear;
    	}
    }

    private void zeroEncoderPosition() {
    	leftMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    	ErrorCode code = rightMasterTalon.setSelectedSensorPosition(0, 0, RobotMap.timeoutMs);
    	System.out.println(code);
    }

    //====================================================
    // Debug Methods
    
    public void publishVelocityToShuffleBoard() {
    	SmartDashboard.putNumber("Left Side Velocity", encoderUnitsToFeetPerSec(leftMasterTalon.getSelectedSensorVelocity(0)));
    	SmartDashboard.putNumber("Right Side Velocity", encoderUnitsToFeetPerSec(rightMasterTalon.getSelectedSensorVelocity(0)));
    }
    
    public void publishTopSpeed() {
    	topLeft = topLeft < leftMasterTalon.getSelectedSensorVelocity(0) ? leftMasterTalon.getSelectedSensorVelocity(0) : topLeft;
    	topRight = topRight < rightMasterTalon.getSelectedSensorVelocity(0) ? rightMasterTalon.getSelectedSensorVelocity(0) : topRight;
    	SmartDashboard.putNumber("Top Left Side Velocity", topLeft);
    	SmartDashboard.putNumber("Top Right Side Velocity", topRight);
    }
}

